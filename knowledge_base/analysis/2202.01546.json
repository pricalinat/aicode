{
  "paper_id": "2202.01546",
  "title": "Queryer Deduplication",
  "category": "product_matching",
  "status": "success",
  "summary": "QueryER is a framework for answering SPJ SQL queries directly over dirty, duplicate-containing data while still returning results equivalent to querying a fully deduplicated database, but faster by deduplicating only the data that affects the query. It integrates Entity Resolution into query planning and execution by inserting ER-aware operators into the query plan and using cost estimates to reduce the dominant expense: pairwise entity comparisons. *QueryER executes analysis-aware deduplication by weaving ER operators into the query plan.* *The experimental evaluation of our approach exhibits that it adapts to the workload and scales on both real and synthetic datasets.*\n\nThe paper introduces three core relational operators:  \n- **Deduplicate**: takes the entities selected by the query from a table and finds their duplicates in that table via an ER pipeline embedded inside the operator: query blocking (schema-agnostic token blocking), block-join with a prebuilt table block index, meta-blocking (block purging, block filtering, edge pruning), then comparison execution using schema-agnostic attribute comparisons; it also updates an in-memory link index so later queries can reuse discovered duplicate links.  \n- **Deduplicate-Join**: a join operator that is aware of whether each input side is dirty or already deduplicated; it deduplicates one side before joining to preserve correctness, then performs a dedupe-aware join that considers duplicate sets when producing joined results.  \n- **Group-Entities**: aggregates each duplicate set into a single grouped output entity by concatenating attribute values (including retaining conflicting values and filling missing ones), so the final projection presents one row per real-world entity.\n\nFor planning and evaluation, QueryER supports a naive placement of Deduplicate near table scans, and an advanced cost-based approach that chooses operator placement and join-side cleaning order to minimize comparisons while ensuring correctness. The planner estimates comparisons using WHERE literals as blocking keys and approximations up through block purging and filtering, and estimates join effects using offline sampling to derive duplication factors plus precomputed join percentages between table pairs. The implementation uses lightweight in-memory indices per table: a table block index mapping blocks to record ids, an inverse mapping from record ids to blocks (sorted by block size), and a link index storing discovered duplicate links; a query block index is built on the fly for each query subset.\n\nExperiments (Java implementation) evaluate effectiveness and performance on multiple real, modified-real, and synthetic datasets, using pair completeness for recall and total execution time plus executed comparisons for efficiency. Results show QueryER typically outperforms a batch deduplicate-then-query baseline, especially at low selectivity, and scales sub-linearly as dataset size grows for fixed query result size; execution time tracks executed comparisons closely in many settings. The link index yields progressive speedups across overlapping queries, while meta-blocking configuration trades small recall loss for large time savings, and the cost-based planner improves SPJ query performance by cleaning the side that leads to fewer comparisons and by exploiting low join percentages to avoid unnecessary deduplication work. The paper concludes by proposing extensions to additional query classes (like aggregation and analytical queries), broader blocking and matching options, and distributed scaling.",
  "file_path": "/Users/rrp/Documents/aicode/data/papers/product_matching/2202.01546_queryER_deduplication.pdf"
}