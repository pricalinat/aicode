{
  "paper_id": "2403.06021",
  "title": "Hierarchical Query",
  "category": "product_matching",
  "year": 2024,
  "timestamp": "2026-03-01T13:43:58.346693",
  "summary": "# Hierarchical Query Classification in E-commerce Search\n\n## Overview\n\nThis paper presents a novel semi-supervised framework for classifying e-commerce search queries into hierarchical category structures. The authors address two primary challenges that make hierarchical query classification difficult in real-world settings: severe class imbalance (sensitive queries represent less than 0.05% to 0.15% of all queries on Amazon) and the inherent brevity and ambiguity of typical search queries averaging only three words in length.\n\nThe proposed method introduces three key components. First, an **instance hierarchy** uses contrastive learning at both intra-class and inter-class levels to capture fine-grained relationships between queries within the same child category while distinguishing them from queries in different child categories under the same parent. Second, a **label hierarchy** incorporates semantic information from label text (such as \"self-harm\" or \"adult products\") by creating a label graph processed through graph convolutional networks, with attention mechanisms to weight relevant label features for each query. Third, a **neighborhood-aware sampling** technique selects high-quality unlabeled queries for self-training by computing KL divergence scores between predicted labels of unlabeled queries and their labeled neighbors, effectively leveraging queries that share typographical or semantic similarities.\n\n## Methodology\n\nThe framework employs BERT to generate initial query embeddings, then enhances these with label hierarchy information by creating a graph representation of the category taxonomy and applying attention-weighted label features. For contrastive learning, intra-class positives are queries within the same child category, while inter-class positives are queries across different child categories under the same parentâ€”negative pairs are drawn from different parent categories. The final loss combines classification loss with weighted contrastive loss, balanced through hyperparameters. During self-training, the trained classifier predicts labels for unlabeled queries, and neighborhood-aware sampling intelligently selects which of these to add back to the training set based on similarity to labeled queries and divergence in predicted category distributions.\n\n## Results and Evaluation\n\nExperiments were conducted on three datasets: Amazon proprietary data (9-10 million user queries), Web of Science (141 classes, 2-level hierarchy), and RCV1-V2 (103 classes, 4-level hierarchy). The proposed method achieved the best performance in most cases, particularly excelling on Macro-F1 metrics critical for imbalanced datasets. On Amazon data, the method outperformed fine-tuned BERT by +3.26% on Micro-F1 and +4.10% on Macro-F1. Ablation studies confirmed that each component contributes to performance, with label hierarchy removal causing the largest drop, indicating its particular importance. The method was deployed in Amazon's sensitive query detection platform, showing improved precision over the previous rule-based production model.\n\n## Limitations and Future Work\n\nThe authors acknowledge several limitations. The multi-stage framework requires manual configuration and monitoring during self-training to determine the number of high-quality datapoints. The system remains vulnerable to adversarial attacks where users intentionally craft queries to bypass classifiers. While the method outperformed ChatGPT on preliminary Web of Science dataset tests, comprehensive comparison with large language models requires further investigation. Additionally, the approach still requires substantial annotated data, suggesting few-shot learning as a promising direction for future research, especially for sensitive categories with very limited training examples.",
  "llm_info": {
    "provider": "cli",
    "model": "cli/claude/sonnet",
    "maxCompletionTokens": null,
    "strategy": "single"
  }
}